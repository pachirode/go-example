# defer

简化执行各种清理操作的函数，后面跟一个函数的调用，该函数会被推迟到外层函数返回的那一刻

### 执行顺序

后进先出，`defer` 可以被定义在任何位置，也可以嵌套

### 读写函数返回值

采用闭包可以实现修改返回值
如果不采用闭包，传递参数给函数，会被立刻求值

### 释放资源

不要在循环中使用 `defer`，语句的调用会在循环以后才开始执行，如果打开的资源过多可能会导致程序中断

解决这个问题
- 匿名函数中执行 `defer`，匿名函数执行完可以立即释放资源
- 函数封装
- 类似上下文管理器

### 结构体方法使用指针接收者

`defer` 调用的参数在调用时就会被计算，而不是实际执行时

使用结构体，方法调用的是对象副本，即使后面修改也不会影响
使用指针接收者，复制的是指针地址，修改的值会同步

如果使用匿名函数无法捕获到外部的变化，只能在最后统一调用

### os.Exit

如果出现 `os.Exit`，函数会直接结束，不会调用 `defer`

### defer nil 会触发 panic

### 面试题

[打印结果](defer/question/main.go)

`Go 1.22` 之前 `for` 循环变量只会被创建一次，每次迭代更新，结果是 `3 3 3`，解决闭包可以解决这个问题
新版本之后，每次迭代都会创建的新的变量，避免意外的内存共享错误








# panic

无法挽回的异常，直接终止当前的流程
触发有两种方式，非法操作导致的运行错误或者主动调用

函数调用 `F` 调用 `panic`，函数的执行会被停止下来，接着调用之前的所有 `defer`，将结果返回调用者

> 退出码：0 程序正常执行完毕；1 通用错误；2 程序因 panic 异常退出

### 子 Goroutine 中 panic

在子 `Goroutine` 中发生 `panic` 会导致主 `Goroutine` 立即退出

### os.Exit

会立即终止程序，并返回指定的状态码给操作系统，`defer` 不会再执行，不会将结果返回给调用者，也不会触发堆栈追踪


# recover

用来将程序从 `panic` 所导致的程序崩溃中恢复执行

`recover` 只有在 `defer` 语句的上下文中才有效，直接调用会返回 `nil`
正确调用的情况下 `recover` 的返回值是 `panic` 函数的参数

调用 `recover` 的 `defer` 应该放在函数的入口成为第一个 `defer`

### 只能捕获当前 `Goroutine` 中的 `panic`

### 转换为 error 返回

防止调用他人不可控代码出现意外中断

### panic(nil)

`go 1.21` 之前 `panic(nil)` 无法被 `recover` 捕获
`GODEBUG=panicnil=1` 标志恢复旧版本的 `panic` 行为

### 不是所有 `panic` 都可以被捕获

从 `go 1.19` 开始遇到不可恢复的致命错误（并发写入 `map` 或者解锁未锁定的互斥锁），只会打印一个简化的堆栈信息，不包含运行时的元数据
> 涉及到并发的操作，不能使用 `map` ，需要使用 `sync.Map` 来替代

`GOTRACEBACK=system` 或者 `GOTRACEBACK=crash` 可以输出更加详细的堆栈信息

### 应用

##### 数据库事务

创建一个事物，接着使用 `defer + recover` 来确保程序执行中间遇到 `panic` 能给回滚事物
如果事物已经成功提交，再执行回滚不会影响最终结果