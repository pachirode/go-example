# errgroup

用于并发的执行多个 `goroutine`，基于 `sync.WaitGroup` 基础实现

### 对比 `sync.WaitGroup`

##### 错误处理

`sync.WaitGroup` 只负责等待 `goroutine` 完成，不处理返回值或者错误

`errgroup.Group` 不能直接处理 `goroutine` 的返回值 ，但是一个返回错误时，可以取消其他 `goroutine`，并返回第一个非 `nil` 的错误

##### 上下文取消

`errgroup` 可以和 `context.Context` 配合使用，在某个 `goroutine` 失败时自动取消其他的

##### 简化并发编程

`errgroup` 可以减少错误处理的样板代码，开发者不需要手动管理错误状态和同步逻辑

##### 限制并发数量

提供便捷接口来限制并发 `goroutine` 数量，`SetLimit`

##### 尝试启动

`TryGo` 尝试启动一个任务，返回一个 `bool` 值，识别任务是否成功启动
需要配合 `SetLimit`，如果不限制并发数量，会始终返回 `true`

# sync.Once

一种同步原语，确保一个操作在程序的生命周期只能被执行一次

`Once` 对象不能被复制

在多个 `goroutine` 中，`once.Do(f)` 首次被调用，函数会执行，并保证它的执行结果在内存中对其他的 `goroutine` 都是可见的
之后再次调用这个方法，不会重新执行函数，它们会同步函数的结果

### 使用场景

- 单例模式
- 懒加载
- 并发安全初始化

### 源码

结构体

- `_ noCopy`
    - 标识这个结构体不可以复制
- `done atomic.Uint32`
    - 故意被放在结构体第一个字段，可以减少 `CPU` 执行的指令数，优化性能
- `m    Mutex`

`Do` 方法

只有第一执行才会进入到 `slow-path`，将 `slow-path` 分离出来是为了对 `fast-path` 进行内联优化

- `fast-path`
    - 针对常见操作或最佳情况进行优化的代码路径
    - 需要避免高成本操作
        - 加锁
        - `IO` 操作
- `slow-path`
    - 处理罕见复杂的情况，通常执行步骤较多

# sync.OnceFunc

返回一个仅调用 `f` 一次的函数，返回的函数可以并发调用
如果函数调用出现 `panic`，返回的函数每次调用都会产生相同的 `panic`

# sync.OnceValue

使用了泛型，接收函数带有返回值，返回函数可带有返回值

# sync.WaitGroup

阻塞等待一组并发任务的完成，会在内部维护一个计数器，`wg.Add(1)` 计数器加一，`wg.Done` 计数器减一，`wg.Wait()`
阻塞调用者 `goroutine`，直到计数器为 0
`sync.WaitGroup` 零值可用

### 源码

- `nocpoy`
    - 用于标识结构体不能被复制
- `state`
    - 原子类型，高 32 位是计数器的值，低 32 位是等待者的数量
- `sema`
    - 信号量，阻塞和唤醒 `waiter`

### Done

计数器 `counter` 减 1，相当于调用 `wg.Add(-1)`

### Add

通过移位操作获取 `counter` 和 `waiter` 的值
校验 `counter` 不能为负，`Add` 和 `Wait` 不能并发调用，否则会触发 `panic`
计数器为 `0`，唤起 `wg.Wait` 阻塞，在此之前会再次进行校验，如果添加任务会触发 `panic`

### Wait

使用无限循环，重试 `CAS` 操作及时 `CompareAndSwap`，如果成功 `waiter` 数量加一

# sync.Cond

并发原语，通过一个条件来实现阻塞和唤醒一组需要协作的 `goroutine`
调用 `Wait` 时，当前 `goroutine` 会被阻塞，直到其他调用 `Broadcast` 或者 `Signal`

### 源码

- `noCopy`
    - 静态检查
- `L`
    - 互斥锁，修改条件时需要持有
- `notify`
    - 记录被阻塞的等待队列，维护一个通知列表
    - 协调 `goroutine` 的阻塞和唤醒
- `checker`
    - 同样防止结构体被复制，运行时进行动态检查

# 内联优化

编译时的优化技术，它是将被调用的函数体直接嵌入到调用处，而不是生成一次真正的函数调用，这样可以减少函数调用的开销

`go build -gcflags='-m'` 构建参数可以查看内联情况，日志中 `inlining` 表示使用了内联优化

# singleflight

官方扩展库提供的扩展并发的原语，可以将多个并发请求合并为一个，主要作用是抑制重复的并发调用

如果多个 `goroutine` 并发调用同一个函数，`singleflight`
可以只让一个发起调用，其他的都阻塞住，等调用结果返回，在同时返回给多个 `goroutine`

读操作较为常见，写操作需要慎重

### 应用场景

大量的请求读取 `redis` 缓存，发现缓存失效，继续向下请求 `mysql`
此时可以使用 `singleflight` 合并请求，只保留一个请求去调用 `mysql` 数据库，然后将结果返回给所有请求

### 源码

##### Group

- `mu sync.Mutex`
    - 互斥锁，用来保护下面 `m` 的访问
- `m  map[string]*call`
    - 键是调用 `singleflight.Do` 传入的第一个参数 `key`

方法

- `Do`
- `DoChan`
- `Forget`
    - 忘记一个 `key`，再次调用上面两个方法，不会等待之前未完成的函数执行结果

##### call

- `wg sync.WaitGroup`
- `val interface{}`
    - 记录函数返回值
- `err error`
    - 记录函数错误
- `dups  int`
    - 从缓存中获取需要返回的次数
- `chans []chan<- Result`
    - 为 `DoChan` 提供返回值

一个正在执行的 `in-flight` 或者已经完的 `fn` 函数的调用

##### doCall

- 双层 `defer` 设计
    - 第一层用于捕获 `panic`
    - 第二层用于处理 `runtime.Goexit` 和资源的释放
- `panic` 处理
    - 通过 `goroutine` 执行 `panic(e)` 保证不会阻塞 `channel` 调用

##### 使用场景

缓存击穿

缓存中某个热点键过期，导致大量请求同时访问数据库，导致系统高压
确保缓存重建过程中，只有一个请求会访问数据库

远程服务调用
多个并发请求访问同一个远程服务
使相同的请求合并为一次

定时任务去重
分布式系统中，可能多个节点同时执行定时任务
只有一个节点执行任务，其他节点共享结果

消息去重
消息队列中存在重复消息的消费问题
消费端保证相同的消息只会处理一次

分布式锁优化
多个节点同时抢锁，可能会引发大量重试的加锁操作
降低对分布式锁的访问压力，只允许一个请求进行加锁操作

# sync.semaphore

官方扩展库提供的扩展原语，信号量，控制多个 `goroutine` 之间的协作

信号量是用来帮助管理有限的资源，假如目前有三个资源

- 每当有程序需要申请这个资源，如果资源有剩余，就可以被分配
- 没有剩余资源需要等待
- 程序使用完，释放资源，可用资源恢复一个

### 源码解读

##### Weighted

结构体标识信号量对象

- `size int64`
    - 资源总数
- `cur int64`
    - 当前使用资源数
- `mu sync.Mutex`
    - 互斥锁
- `waiters int64`
    - 等待队列

方法

- `Acquire(ctx context.Context, n int64) error`
    - 用来请求 `n` 个资源，如果资源不足则阻塞，直到资源够或者 `ctx` 被取消
- `Release(n int64)`
    - 释放资源
- `TryAcquire(n int64) bool`
    - 请求资源，不会阻塞，返回是否成功

###### Acquire

- 检查 `ctx` 是否被取消，分配资源前被取消返回 `ctx.Err`
- 检查剩余资源是否满足条件，资源足够不存在等待者，返回资源
- 校验请求资源数是否合法，请求大于资源总数，取消返回错误
- 当前资源不够，存在其他等待者，阻塞等待
    - 创建一个等待着对象 `waiter`，加入等待着队列
    - 如果取消
        - 在检查一次是否唤醒
    - 唤醒
        - 检查是否取消

# sync.map

`map` 基本数据类型不是并发安全的，`sync` 包中提供了 `map` 的并发原语，允许并发操作

### 核心结构体

设计类似缓存系统，当需要读取值的时候，优先从缓存中读取，如果缓存未命中，继续从数据库中读取
特定条件下会同步缓存和数据库中的数据

Map

- `mu`
    - 保护 `dirty map` 的互斥锁
- `read`
    - 只读 `map`，原子操作无需加锁
    - 类比缓存
- `dirty`
    - 可变数据，包含所有数据，操作时需要加锁
    - 类比为数据库
- `misses`
    - 记录 `read map` 的 `miss` 数量
    - 记录缓冲未命中次数，到达阈值时，同步缓存

readonly

- `m       map[any]*entry`
    - 存储只读 `map` 数据
- `amended bool`
    - 是否有新的 `key` 只存在于 `dirty map`
    - 如果 `false` 表示缓存和数据库一致，无需继续读取

entry

- `p atomic.Pointer[any]`
    - 存储值的指针
    - 所有存入的值都会包装成这个对象
    - 三种状态
        - 值为一个对象指针，正常状态
        - 值为 `nil`，键值对已经被删除
        - 值为 `expunged`，键值对已经被彻底删除

expunged

- 全局变量，值为任意一个指针，标记某个键值对已经被删除

### 方法

Store

将指定的键值对存入 `sync.Map`，实际将操作代理到 `Swap`

Swap

交换给定的 `key` 对应值，并返回之前的旧值

- 尝试从 `read` 中获取给定的 `key` 对应的值 `entry`
    - `key` 存在，尝试交换 `key` 对应的值
        - 交换成功，更新操作
        - `key` 没有被彻底删除，为创建操作
        - 以及被彻底删除，交换失败
- 从 `dirty` 中获取数据，同时重载 `read`
    - 判断是否在 `read`
        - 存在，将 `entry` 的值更新成新值
    - 仅存在 `dirty`
        - 直接更新
    - 都不存在
        - 创建新的键值对，创建新的 `entry`

如果 `entry` 的值为 `expunged`，表明已经被彻底删除了，无法交换值
如果允许交换 `read` 会比 `dirty` 中多值

Load

从 `sync.Map` 中读取给定的 `key` 对应的值，缓存未命中调用 `missLocked`

missLocked

调用一次 `misses` 计数加一，当次数达到 `dirty` 中全量数据长度，`dirty` 直接提升为 `read`

Range

遍历 `sync.Map` 中的所有键值对，并依次调用给定的 `f(key,value)` 函数，如果函数返回 `false`，则停止遍历

# redsync

分布式锁，服务可能会采用多副本集群部署方案，主要用来解决多个进程之间并发资源抢占的问题

`redsync` 是 `redis` 官方推荐使用的，遵循 `Redlock` 算法，适用于需要强一致性的分布式场景

- `sync.Mutex`
    - 单个进程内多个协程
    - 内存共享资源保护
- `redsync`
    - 多进程
    - 涉及到网络通信
    - 需要处理网络，超时等问题
    - 分布式系统共享资源

### 使用

依赖于 `Redis`，需要先创建一个 `redis` 客户端对象

##### 看门狗

锁自动续期

# sync.Pool

创建对象池，用于缓存和复用临时对象，减少内存分配和垃圾回收的压力

使用场景
- 频繁创建和销毁对象
- 复用对象减少 `GC`
- 不包含上下文的无状态对象
使用
- 对象使用之前需要重置状态
- 池中的对象会被 `GC`，不能长期依赖池中的对象
  - 如果池中的对象没被使用，连续两次 `GC` 之后会被回收