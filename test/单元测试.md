# 测试分类

- 单元测试
- 基准测试
- 示例测试
- 模糊测试

- 白盒测试
    - 测试代码和被测代码放在同一个包中，可以使用测试当前包中所有标识符
- 黑盒测试
    - 测试代码和被测代码不再同一个包中，仅可以使用能被导出的标识符

# 单元测试

### 表格测试

```text
func TestXxx(t *testing.T) {
	tests := []struct {
		Name string
		arg  float64
		want float64
	}{
		...
	}
	for _, tt := range tests {
		t.Run(tt.Name, func(t *testing.T) {
			if got := Xxx(tt.arg); got != tt.want {
				t.Errorf("Xxx(%f) = %v, want %v", tt.arg, got, tt.want)
			}
		})
	}

	cases := []struct {
		Name string
		arg  float64
		want float64
	}{
		...
	}
	for _, cc := range cases {
		t.Run(cc.Name, func(t *testing.T) {
			if got := Xxx(cc.arg); got != cc.want {
				t.Errorf("Xxx(%f) = %v, want %v", cc.arg, got, cc.want)
			}
		})
	}
}
```

### 使用环境变量跳过部分测试

```text
func TestAbs_Skip(t *testing.T) {
  // CI 环境跳过当前测试
  if os.Getenv("CI") != "" {
  t.Skip("it's too slow, skip when running in CI")
}

t.Log(t.Skipped())

got := Abs(-2)
  if got != 2 {
  t.Errorf("Abs(-2) = %f; want 2", got)
  }
}

CI = 1 go test -v -run = "TestAbs_Skip"
```

### 测试函数支持并发

使用 `(*testint.T).Parallel` 可以设置测试函数支持并发执行

如果存在多个并发测试案例，测试函数不会一次性执行完毕，日志中会出现 `PAUSE` 表示暂停，`CONT` 表示恢复

### `TestMain`

单元测试的一个约定名称，相当于 `main` 函数，执行所有测试用例之前，会优先执行该函数
在该函数调用 `m.Run()`，`(*testing.M).Run()` 方法会执行全部的用例，所有用例执行完之后，代码会执行 `ts.Close()`

### HTTP 网络依赖

- 替换数据库或者其他业务层
    - 确定需要依赖的业务层数据结构，使用测试替身来替换
- `net/http/httptest` 标准库，实现了一些专门进行网络测试的工具

##### `net/http/httptest`

- `HTTP` 响应对象
    - `w := httptest.NewRecorder()`
- `HTTP` 请求对象
    - `req := httptest.NewRequest("POST", "url", body)`
- 请求路由参数
    - `(*httprouter.Router).ServeHTTP` 可以调用请求对应的 `Handler` 函数，根据请求对象自动调用函数

##### `gock`

第三方包，拦截所有被 `mock` 的 `HTTP` 请求，返回 `mock` 的数据，这个包是 `HTTP` 请求的 `Mock` 框架

### `Mysql` 存储依赖

`mysql` 外部依赖的程序调用链

- `UserHandler`
- `store.UserStore`
- `store.userStore`
- `*gorm.DB`

##### `Fake object`

新写一个 `Fake object` 用来替换 `store.userStore`，需要实现上层接口的所有方法，耗时比较长

##### `Mock`

使用模拟对象断言真实对象被调用之后输入的符合预期的值

- `gomock`
    - 管理被 `mock` 对象的生命周期
- `mockgen`
    - 自动生成 `mock` 代码

###### 指定源码

生成 `Mock` 代码 `mockgen -source store/store.go -destination store/mocks/gomock.go -package mocks`

- `-source`
    - 需要 `Mock` 的接口文件地址
- `-destination`
    - 生成的 `Mock` 文件路径
- `-package`
    - 生成 `Mock` 文件包名

###### 反射

`mockgen -package mocks -destination store/mocks/gomock.go github.com/pachirode/go-example/test/mysql/store UserStore`

###### 使用生成注释

`mockgen -package mocks -destination store/mocks/gomock.go github.com/jianghushinian/blog-go-example/test/mysql/store UserStore`

执行 `go generate ./...`，查找项目下全部文件夹

### `Redis` 存储依赖

##### `redismock`

实现模拟 `redis` 客户端，需要保证 `redismock` 和 `go-redis` 版本一致

```text
rdb, mock := redismock.NewClientMock()
mock.ExpectGet("sms:captcha:XXX").SetVal("123456")
mock.ExpectSet("sms:captcha:XXX", "XXX", 24*time.Hour).SetVal("OK")
```

##### `Testcontainers`

使用容器来运行一个真正的外部服务，需要依赖 `docker` 环境

### 文件依赖

##### 临时文件

不同的机器上文件路径不相同，不能使用真实路径来进行测试，使用临时文件

##### `Go embed`

将文件内容嵌入到变量中

##### `embed fs.FS`

文件嵌入称为一个文件系统

### 猴子补丁

- `github.com/agiledragon/gomonkey/v2`
- `github.com/xhd2015/xgo/runtime/mock`
    - 使用 `xgo` 替换 `go test`

# 示例测试

以 `Example` 开头，无参数和返回值，通常存放在 `example_test.go` 文件中
如果存在多个示例测试，可以通过在名称后面附加不同的后缀来命名，后缀必须以小写字母开头
示例函数末尾需要使用 `// Output:` 注释，来标记被测试函数的标准输出内容，`// Unordered Output:` 忽视顺序

示例测试另外一个重要的功能是被 `godoc` 或者 `pkgsite` 工具识别，作为测试文档的一部分

